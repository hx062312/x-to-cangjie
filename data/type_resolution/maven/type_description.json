{
    "java.lang.Object": {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html",
        "text": "Class Object is the root of the class hierarchy.\n Every class has Object as a superclass. All objects,\n including arrays, implement the methods of this class.",
        "summarized_text": "Class Object is the root of the class hierarchy"
    },
    "double": {
        "link": "",
        "text": "",
        "summarized_text": ""
    },
    "java.util.function.ToDoubleFunction<CartItem>": {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/util/function/ToDoubleFunction.html",
        "text": "Represents a function that produces a double-valued result.  This is the\n double-producing primitive specialization for Function.\n\n This is a functional interface\n whose functional method is applyAsDouble(Object).",
        "summarized_text": "Represents a function that produces a double-valued result"
    },
    "java.lang.UnsupportedOperationException": {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/lang/UnsupportedOperationException.html",
        "text": "Thrown to indicate that the requested operation is not supported.\n\n This class is a member of the\n \n Java Collections Framework.",
        "summarized_text": "Thrown to indicate that the requested operation is not supported"
    },
    "boolean": {
        "link": "",
        "text": "",
        "summarized_text": ""
    },
    "java.lang.IllegalArgumentException": {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/lang/IllegalArgumentException.html",
        "text": "Thrown to indicate that a method has been passed an illegal or\n inappropriate argument.",
        "summarized_text": "Thrown to indicate that a method has been passed an illegal or\n inappropriate argument"
    },
    "java.util.function.Consumer<CartItem>": {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html",
        "text": "Represents an operation that accepts a single input argument and returns no\n result. Unlike most other functional interfaces, Consumer is expected\n to operate via side-effects.\n\n This is a functional interface\n whose functional method is accept(Object).",
        "summarized_text": "Represents an operation that accepts a single input argument and returns no\n result"
    },
    "java.lang.StringBuilder": {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html",
        "text": "A mutable sequence of characters.  This class provides an API compatible\n with StringBuffer, but with no guarantee of synchronization.\n This class is designed for use as a drop-in replacement for\n StringBuffer in places where the string buffer was being\n used by a single thread (as is generally the case).   Where possible,\n it is recommended that this class be used in preference to\n StringBuffer as it will be faster under most implementations.\n\n The principal operations on a StringBuilder are the\n append and insert methods, which are\n overloaded so as to accept data of any type. Each effectively\n converts a given datum to a string and then appends or inserts the\n characters of that string to the string builder. The\n append method always adds these characters at the end\n of the builder; the insert method adds the characters at\n a specified point.\n \n For example, if z refers to a string builder object\n whose current contents are \"start\", then\n the method call z.append(\"le\") would cause the string\n builder to contain \"startle\", whereas\n z.insert(4, \"le\") would alter the string builder to\n contain \"starlet\".\n \n In general, if sb refers to an instance of a StringBuilder,\n then sb.append(x) has the same effect as\n sb.insert(sb.length(), x).\n \n Every string builder has a capacity. As long as the length of the\n character sequence contained in the string builder does not exceed\n the capacity, it is not necessary to allocate a new internal\n buffer. If the internal buffer overflows, it is automatically made larger.\n\n Instances of StringBuilder are not safe for\n use by multiple threads. If such synchronization is required then it is\n recommended that StringBuffer be used.\n\n Unless otherwise noted, passing a null argument to a constructor\n or method in this class will cause a NullPointerException to be\n thrown.",
        "summarized_text": "A mutable sequence of characters"
    },
    "java.util.ArrayList<CartItem>": {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html",
        "text": "Resizable-array implementation of the List interface.  Implements\n all optional list operations, and permits all elements, including\n null.  In addition to implementing the List interface,\n this class provides methods to manipulate the size of the array that is\n used internally to store the list.  (This class is roughly equivalent to\n Vector, except that it is unsynchronized.)\n\n The size, isEmpty, get, set,\n iterator, and listIterator operations run in constant\n time.  The add operation runs in amortized constant time,\n that is, adding n elements requires O(n) time.  All of the other operations\n run in linear time (roughly speaking).  The constant factor is low compared\n to that for the LinkedList implementation.\n\n Each ArrayList instance has a capacity.  The capacity is\n the size of the array used to store the elements in the list.  It is always\n at least as large as the list size.  As elements are added to an ArrayList,\n its capacity grows automatically.  The details of the growth policy are not\n specified beyond the fact that adding an element has constant amortized\n time cost.\n\n An application can increase the capacity of an ArrayList instance\n before adding a large number of elements using the ensureCapacity\n operation.  This may reduce the amount of incremental reallocation.\n\n Note that this implementation is not synchronized.\n If multiple threads access an ArrayList instance concurrently,\n and at least one of the threads modifies the list structurally, it\n must be synchronized externally.  (A structural modification is\n any operation that adds or deletes one or more elements, or explicitly\n resizes the backing array; merely setting the value of an element is not\n a structural modification.)  This is typically accomplished by\n synchronizing on some object that naturally encapsulates the list.\n\n If no such object exists, the list should be \"wrapped\" using the\n Collections.synchronizedList\n method.  This is best done at creation time, to prevent accidental\n unsynchronized access to the list:\n   List list = Collections.synchronizedList(new ArrayList(...));\n\n The iterators returned by this class's iterator and\n listIterator methods are fail-fast:\n if the list is structurally modified at any time after the iterator is\n created, in any way except through the iterator's own\n remove or\n add methods, the iterator will throw a\n ConcurrentModificationException.  Thus, in the face of\n concurrent modification, the iterator fails quickly and cleanly, rather\n than risking arbitrary, non-deterministic behavior at an undetermined\n time in the future.\n\n Note that the fail-fast behavior of an iterator cannot be guaranteed\n as it is, generally speaking, impossible to make any hard guarantees in the\n presence of unsynchronized concurrent modification.  Fail-fast iterators\n throw ConcurrentModificationException on a best-effort basis.\n Therefore, it would be wrong to write a program that depended on this\n exception for its correctness:  the fail-fast behavior of iterators\n should be used only to detect bugs.\nThis class is a member of the\n \n Java Collections Framework.",
        "summarized_text": "Resizable-array implementation of the List interface"
    },
    "java.lang.Math": {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html",
        "text": "The class Math contains methods for performing basic\n numeric operations such as the elementary exponential, logarithm,\n square root, and trigonometric functions.\n\n Unlike some of the numeric methods of class\n StrictMath, all implementations of the equivalent\n functions of class Math are not defined to return the\n bit-for-bit same results.  This relaxation permits\n better-performing implementations where strict reproducibility is\n not required.\n\n By default many of the Math methods simply call\n the equivalent method in StrictMath for their\n implementation.  Code generators are encouraged to use\n platform-specific native libraries or microprocessor instructions,\n where available, to provide higher-performance implementations of\n Math methods.  Such higher-performance\n implementations still must conform to the specification for\n Math.\n\n The quality of implementation specifications concern two\n properties, accuracy of the returned result and monotonicity of the\n method.  Accuracy of the floating-point Math methods is\n measured in terms of ulps, units in the last place.  For a\n given floating-point format, an ulp of a\n specific real number value is the distance between the two\n floating-point values bracketing that numerical value.  When\n discussing the accuracy of a method as a whole rather than at a\n specific argument, the number of ulps cited is for the worst-case\n error at any argument.  If a method always has an error less than\n 0.5 ulps, the method always returns the floating-point number\n nearest the exact result; such a method is correctly\n rounded.  A correctly rounded method is generally the best a\n floating-point approximation can be; however, it is impractical for\n many floating-point methods to be correctly rounded.  Instead, for\n the Math class, a larger error bound of 1 or 2 ulps is\n allowed for certain methods.  Informally, with a 1 ulp error bound,\n when the exact result is a representable number, the exact result\n should be returned as the computed result; otherwise, either of the\n two floating-point values which bracket the exact result may be\n returned.  For exact results large in magnitude, one of the\n endpoints of the bracket may be infinite.  Besides accuracy at\n individual arguments, maintaining proper relations between the\n method at different arguments is also important.  Therefore, most\n methods with more than 0.5 ulp errors are required to be\n semi-monotonic: whenever the mathematical function is\n non-decreasing, so is the floating-point approximation, likewise,\n whenever the mathematical function is non-increasing, so is the\n floating-point approximation.  Not all approximations that have 1\n ulp accuracy will automatically meet the monotonicity requirements.\n\n \n The platform uses signed two's complement integer arithmetic with\n int and long primitive types.  The developer should choose\n the primitive type to ensure that arithmetic operations consistently\n produce correct results, which in some cases means the operations\n will not overflow the range of values of the computation.\n The best practice is to choose the primitive type and algorithm to avoid\n overflow. In cases where the size is int or long and\n overflow errors need to be detected, the methods addExact,\n subtractExact, multiplyExact, and toIntExact\n throw an ArithmeticException when the results overflow.\n For other arithmetic operations such as divide, absolute value,\n increment, decrement, and negation overflow occurs only with\n a specific minimum or maximum value and should be checked against\n the minimum or maximum as appropriate.",
        "summarized_text": "The class Math contains methods for performing basic\n numeric operations such as the elementary exponential, logarithm,\n square root, and trigonometric functions"
    },
    "java.lang.System": {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/lang/System.html",
        "text": "The System class contains several useful class fields\n and methods. It cannot be instantiated.\n\n Among the facilities provided by the System class\n are standard input, standard output, and error output streams;\n access to externally defined properties and environment\n variables; a means of loading files and libraries; and a utility\n method for quickly copying a portion of an array.",
        "summarized_text": "The System class contains several useful class fields\n and methods"
    },
    "java.lang.Integer": {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html",
        "text": "The Integer class wraps a value of the primitive type\n int in an object. An object of type Integer\n contains a single field whose type is int.\n\n In addition, this class provides several methods for converting\n an int to a String and a String to an\n int, as well as other constants and methods useful when\n dealing with an int.\n\n Implementation note: The implementations of the \"bit twiddling\"\n methods (such as highestOneBit and\n numberOfTrailingZeros) are\n based on material from Henry S. Warren, Jr.'s Hacker's\n Delight, (Addison Wesley, 2002).",
        "summarized_text": "The Integer class wraps a value of the primitive type\n int in an object"
    },
    "java.util.List<CartItem>": {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/util/List.html",
        "text": "An ordered collection (also known as a sequence).  The user of this\n interface has precise control over where in the list each element is\n inserted.  The user can access elements by their integer index (position in\n the list), and search for elements in the list.\n\n Unlike sets, lists typically allow duplicate elements.  More formally,\n lists typically allow pairs of elements e1 and e2\n such that e1.equals(e2), and they typically allow multiple\n null elements if they allow null elements at all.  It is not inconceivable\n that someone might wish to implement a list that prohibits duplicates, by\n throwing runtime exceptions when the user attempts to insert them, but we\n expect this usage to be rare.\n\n The List interface places additional stipulations, beyond those\n specified in the Collection interface, on the contracts of the\n iterator, add, remove, equals, and\n hashCode methods.  Declarations for other inherited methods are\n also included here for convenience.\n\n The List interface provides four methods for positional (indexed)\n access to list elements.  Lists (like Java arrays) are zero based.  Note\n that these operations may execute in time proportional to the index value\n for some implementations (the LinkedList class, for\n example). Thus, iterating over the elements in a list is typically\n preferable to indexing through it if the caller does not know the\n implementation.\n\n The List interface provides a special iterator, called a\n ListIterator, that allows element insertion and replacement, and\n bidirectional access in addition to the normal operations that the\n Iterator interface provides.  A method is provided to obtain a\n list iterator that starts at a specified position in the list.\n\n The List interface provides two methods to search for a specified\n object.  From a performance standpoint, these methods should be used with\n caution.  In many implementations they will perform costly linear\n searches.\n\n The List interface provides two methods to efficiently insert and\n remove multiple elements at an arbitrary point in the list.\n\n Note: While it is permissible for lists to contain themselves as elements,\n extreme caution is advised: the equals and hashCode\n methods are no longer well defined on such a list.\n\n Some list implementations have restrictions on the elements that\n they may contain.  For example, some implementations prohibit null elements,\n and some have restrictions on the types of their elements.  Attempting to\n add an ineligible element throws an unchecked exception, typically\n NullPointerException or ClassCastException.  Attempting\n to query the presence of an ineligible element may throw an exception,\n or it may simply return false; some implementations will exhibit the former\n behavior and some will exhibit the latter.  More generally, attempting an\n operation on an ineligible element whose completion would not result in\n the insertion of an ineligible element into the list may throw an\n exception or it may succeed, at the option of the implementation.\n Such exceptions are marked as \"optional\" in the specification for this\n interface.\n\n This interface is a member of the\n \n Java Collections Framework.",
        "summarized_text": "An ordered collection (also known as a sequence)"
    },
    "int": {
        "link": "",
        "text": "",
        "summarized_text": ""
    },
    "DiscountService.DiscountType": {
        "link": "",
        "text": "",
        "summarized_text": ""
    },
    "Executable": {
        "link": "",
        "text": "",
        "summarized_text": ""
    },
    "void": {
        "link": "",
        "text": "",
        "summarized_text": ""
    },
    "java.lang.Double": {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html",
        "text": "The Double class wraps a value of the primitive type\n double in an object. An object of type\n Double contains a single field whose type is\n double.\n\n In addition, this class provides several methods for converting a\n double to a String and a\n String to a double, as well as other\n constants and methods useful when dealing with a\n double.",
        "summarized_text": "The Double class wraps a value of the primitive type\n double in an object"
    },
    "java.util.Collections": {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html",
        "text": "This class consists exclusively of static methods that operate on or return\n collections.  It contains polymorphic algorithms that operate on\n collections, \"wrappers\", which return a new collection backed by a\n specified collection, and a few other odds and ends.\n\n The methods of this class all throw a NullPointerException\n if the collections or class objects provided to them are null.\n\n The documentation for the polymorphic algorithms contained in this class\n generally includes a brief description of the implementation.  Such\n descriptions should be regarded as implementation notes, rather than\n parts of the specification.  Implementors should feel free to\n substitute other algorithms, so long as the specification itself is adhered\n to.  (For example, the algorithm used by sort does not have to be\n a mergesort, but it does have to be stable.)\n\n The \"destructive\" algorithms contained in this class, that is, the\n algorithms that modify the collection on which they operate, are specified\n to throw UnsupportedOperationException if the collection does not\n support the appropriate mutation primitive(s), such as the set\n method.  These algorithms may, but are not required to, throw this\n exception if an invocation would have no effect on the collection.  For\n example, invoking the sort method on an unmodifiable list that is\n already sorted may or may not throw UnsupportedOperationException.\n\n This class is a member of the\n \n Java Collections Framework.",
        "summarized_text": "This class consists exclusively of static methods that operate on or return\n collections"
    },
    "java.util.function.Predicate<CartItem>": {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html",
        "text": "Represents a predicate (boolean-valued function) of one argument.\n\n This is a functional interface\n whose functional method is test(Object).",
        "summarized_text": "Represents a predicate (boolean-valued function) of one argument"
    },
    "java.lang.String": {
        "link": "https://docs.oracle.com/javase/8/docs/api/java/lang/String.html",
        "text": "The String class represents character strings. All\n string literals in Java programs, such as \"abc\", are\n implemented as instances of this class.\n \n Strings are constant; their values cannot be changed after they\n are created. String buffers support mutable strings.\n Because String objects are immutable they can be shared. For example:\n \n     String str = \"abc\";\n \n is equivalent to:\n \n     char data[] = {'a', 'b', 'c'};\n     String str = new String(data);\n \n Here are some more examples of how strings can be used:\n \n     System.out.println(\"abc\");\n     String cde = \"cde\";\n     System.out.println(\"abc\" + cde);\n     String c = \"abc\".substring(2,3);\n     String d = cde.substring(1, 2);\n \n\n The class String includes methods for examining\n individual characters of the sequence, for comparing strings, for\n searching strings, for extracting substrings, and for creating a\n copy of a string with all characters translated to uppercase or to\n lowercase. Case mapping is based on the Unicode Standard version\n specified by the Character class.\n \n The Java language provides special support for the string\n concatenation operator (\u00a0+\u00a0), and for conversion of\n other objects to strings. String concatenation is implemented\n through the StringBuilder(or StringBuffer)\n class and its append method.\n String conversions are implemented through the method\n toString, defined by Object and\n inherited by all classes in Java. For additional information on\n string concatenation and conversion, see Gosling, Joy, and Steele,\n The Java Language Specification.\n\n  Unless otherwise noted, passing a null argument to a constructor\n or method in this class will cause a NullPointerException to be\n thrown.\n\n A String represents a string in the UTF-16 format\n in which supplementary characters are represented by surrogate\n pairs (see the section Unicode\n Character Representations in the Character class for\n more information).\n Index values refer to char code units, so a supplementary\n character uses two positions in a String.\n The String class provides methods for dealing with\n Unicode code points (i.e., characters), in addition to those for\n dealing with Unicode code units (i.e., char values).",
        "summarized_text": "The String class represents character strings"
    }
}